require('dotenv').config();
const { Client, GatewayIntentBits, EmbedBuilder, AttachmentBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const fs = require('fs');
const path = require('path');

// Configuraci√≥n del bot
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildMembers,
        GatewayIntentBits.GuildPresences,
        GatewayIntentBits.GuildVoiceStates
    ]
});

// Variables de configuraci√≥n
const BOT_PREFIX = process.env.BOT_PREFIX || '$';
const BOT_OWNER_ID = process.env.BOT_OWNER_ID;
const SUPPORT_CHANNEL_ID = process.env.SUPPORT_CHANNEL_ID;
const DESCUBRIMIENTOS_CHANNEL_ID = process.env.DESCUBRIMIENTOS_CHANNEL_ID;
const IMPLEMENTACIONES_CHANNEL_ID = process.env.IMPLEMENTACIONES_CHANNEL_ID;
const CHAT_CHANNEL_ID = process.env.CHAT_CHANNEL_ID;
const CMD_CHANNEL_ID = process.env.CMD_CHANNEL_ID;
const ANTICHEAT_WEBHOOK_URL = process.env.ANTICHEAT_WEBHOOK_URL;
const COMMUNITY_SERVER_INVITE = process.env.COMMUNITY_SERVER_INVITE || 'https://discord.gg/stealth-anticheat';

// Base de datos de apodos
const NICKNAMES_FILE = path.join(__dirname, 'nicknames.json');
const DEVELOPERS_FILE = path.join(__dirname, 'developers.json');
const ANTI_CHEAT_DB = path.join(__dirname, 'anti_cheat_analysis.db');

// ========================================
// üß† SISTEMA COMPLETO STEALTH-ANTICHEATX
// ========================================

class StealthAntiCheatXSystem {
    constructor() {
        this.stealthKnowledge = {
            systemName: 'Stealth-AntiCheatX',
            developer: 'xpe.nettt',
            copyright: '2025',
            license: 'MIT License',
            targetPlatform: 'HD-Player (BlueStacks emulator)',
            version: '2.1.0'
        };
        
        this.channelKnowledge = {
            [SUPPORT_CHANNEL_ID]: {
                name: 'Soporte',
                purpose: 'Canal dedicado para resolver dudas t√©cnicas, problemas con el sistema y asistencia general',
                usage: 'Los usuarios pueden reportar problemas, hacer preguntas sobre la configuraci√≥n y solicitar ayuda t√©cnica',
                botRole: 'Asistente t√©cnico activo con conocimiento completo del sistema'
            },
            [DESCUBRIMIENTOS_CHANNEL_ID]: {
                name: 'Descubrimientos',
                purpose: 'Canal para compartir nuevos hallazgos, t√©cnicas de detecci√≥n y an√°lisis de patrones de cheating',
                usage: 'Desarrolladores y analistas comparten descubrimientos, nuevos patrones de malware y t√©cnicas de detecci√≥n',
                botRole: 'Moderador experto que valida hallazgos y proporciona contexto t√©cnico'
            },
            [IMPLEMENTACIONES_CHANNEL_ID]: {
                name: 'Implementaciones',
                purpose: 'Canal para discutir nuevas funcionalidades, actualizaciones y mejoras del sistema anti-cheat',
                usage: 'Documentaci√≥n de nuevas implementaciones, testing de funciones y despliegue de mejoras',
                botRole: 'Coordinador t√©cnico que ayuda con implementaciones y proporciona especificaciones'
            },
            [CHAT_CHANNEL_ID]: {
                name: 'Chat General',
                purpose: 'Canal de conversaci√≥n libre para la comunidad sobre anti-cheat y temas relacionados',
                usage: 'Conversaciones casuales, intercambio de ideas y networking entre miembros de la comunidad',
                botRole: 'Participante activo que puede cambiar de canal cuando los devs lo soliciten'
            },
            [CMD_CHANNEL_ID]: {
                name: 'Comandos',
                purpose: 'Canal exclusivo para comandos del bot y consultas t√©cnicas estructuradas',
                usage: 'Ejecuci√≥n de comandos $anticheat, consultas r√°pidas y acceso a funciones especializadas',
                botRole: 'Ejecutor de comandos principal con todas las funcionalidades disponibles'
            }
        };
        
        this.cheatingPatterns = new Map();
        this.threatDatabase = new Map();
        this.analysisHistory = [];
        this.devMode = false;
        
        this.initializeKnowledgeBase();
        this.initializePatterns();
    }

    initializeKnowledgeBase() {
        // Base de conocimientos completa del sistema Stealth-AntiCheatX
        this.systemKnowledge = {
            detectionCategories: {
                wallhack_esp: {
                    name: 'Wallhacks & ESP Detection',
                    description: 'Detecta overlays transparentes (estilo ESP), monitorea ventanas con estilos sospechosos (0x94000000)',
                    methods: ['Window style enumeration', 'Handle monitoring', 'Module verification'],
                    autoAction: 'Terminaci√≥n autom√°tica de procesos ESP activos'
                },
                aimbot_injection: {
                    name: 'Aimbot & Process Injection',
                    description: 'Escanea DLLs sin firmar en tiempo real, detecta inyecci√≥n de procesos externos',
                    methods: ['Digital signature scanning', 'Thread range verification', 'Process monitoring'],
                    autoAction: 'Alerta inmediata y logging detallado'
                },
                hardware_cheats: {
                    name: 'Hardware Cheats & DMA',
                    description: 'Detecta dispositivos DMA (PCI, USB, Serial, Parallel), monitorea hardware externo no autorizado',
                    methods: ['DMA device detection', 'Peripheral analysis', 'Hardware fingerprinting'],
                    autoAction: 'Bloqueo de dispositivos sospechosos'
                },
                speed_hacks: {
                    name: 'Speed Hacks & Time Manipulation',
                    description: 'Detecta manipulaci√≥n temporal, diferencias entre steady-clock vs wall-clock',
                    methods: ['Temporal drift analysis', 'Debugger detection', 'Clock verification'],
                    autoAction: 'Terminaci√≥n de procesos manipuladores'
                },
                file_integrity: {
                    name: 'File Integrity & System Monitoring',
                    description: 'Verifica SHA1 de DLLs cr√≠ticas del sistema, monitorea modificaciones no autorizadas',
                    methods: ['SHA1 hashing', 'Digital signature verification', 'System file monitoring'],
                    autoAction: 'Restauraci√≥n de integridad del sistema'
                }
            },
            
            protectionFunctionalities: {
                externalProtection: {
                    name: 'External Protection',
                    features: ['Real-time process handle monitoring', 'Suspicious overlay termination', 'Unauthorized handle detection']
                },
                internalProtection: {
                    name: 'Internal Protection', 
                    features: ['Module signature verification', 'Thread range enumeration', 'Unsigned DLL detection']
                },
                timeTamperDetection: {
                    name: 'Time-Tamper Detection',
                    features: ['Steady-clock vs wall-clock drift analysis', 'Speed hack detection', 'Debugger identification']
                },
                selfProtection: {
                    name: 'Self-Protection',
                    features: ['Administrator & SE_DEBUG privileges', 'Console security', 'Anti-tampering mechanisms']
                },
                discordIntegration: {
                    name: 'Discord Community Integration',
                    features: ['Real-time webhook reporting', 'User tracking', 'Crash attempt monitoring']
                },
                audioAlerts: {
                    name: 'Professional Audio Alerts',
                    features: ['ESP: 1000Hz beep', 'DLLs: 800Hz beep', 'Threads: 600Hz beep', 'Time: 750Hz beep']
                },
                systemMonitoring: {
                    name: 'Enhanced System Monitoring',
                    features: ['DMA hardware detection', 'File integrity verification', 'Network analysis']
                }
            },
            
            usageRequirements: {
                operatingSystem: 'Windows 7 or later (x64)',
                development: 'Visual Studio 2017 or newer',
                privileges: 'Administrator & SE_DEBUG privileges required',
                installation: 'Run as Administrator, allow Windows Defender if prompted',
                usage: 'Automatic HD-Player detection, real-time monitoring, no user interaction required'
            },
            
            compilationInfo: {
                automatic: 'GitHub Actions compiles automatically on every push to main branch',
                manual: ['MinGW compilation (build_mingw.bat)', 'Visual Studio compilation (build_release.bat)'],
                releases: 'Automatic EXE upload on Create Release'
            }
        };
    }

    /**
     * Inicializa patrones de detecci√≥n avanzados
     */
    initializePatterns() {
        const patterns = [
            // ESP y Overlays
            { id: 'esp_overlay', name: 'ESP Overlay', severity: 'CRITICAL', 
              patterns: [/GetWindowLongPtr.*ESP/i, /SetWindowLong.*WS_EX_LAYERED/i, /FindWindow.*ESP/i],
              detectionMethod: 'window_enumeration', gameTarget: 'universal',
              description: 'Detecta overlays transparentes de estilo ESP que proporcionan ventajas visuales' },
            
            // Inyecci√≥n de memoria
            { id: 'memory_injection', name: 'Memory Injection', severity: 'CRITICAL',
              patterns: [/VirtualAllocEx.*shellcode/i, /CreateRemoteThread.*Process/i, /NtUnmapViewOfSection/i],
              detectionMethod: 'memory_analysis', gameTarget: 'universal',
              description: 'Detecta t√©cnicas de inyecci√≥n de c√≥digo en memoria de procesos' },
            
            // Lectura/escritura de memoria
            { id: 'memory_manipulation', name: 'Memory Manipulation', severity: 'HIGH',
              patterns: [/ReadProcessMemory.*Process/i, /WriteProcessMemory.*Process/i, /memcpy.*buffer.*process/i],
              detectionMethod: 'memory_access', gameTarget: 'universal',
              description: 'Identifica acceso no autorizado a memoria de procesos del juego' },
            
            // DLL Injection
            { id: 'dll_injection', name: 'DLL Injection', severity: 'CRITICAL',
              patterns: [/LoadLibrary.*dll/i, /GetProcAddress.*GetModuleHandle/i],
              detectionMethod: 'process_analysis', gameTarget: 'universal',
              description: 'Detecta inyecci√≥n de DLLs no autorizadas en procesos del juego' },
            
            // Bots y automatizaci√≥n
            { id: 'bot_automation', name: 'Bot Automation', severity: 'HIGH',
              patterns: [/SendInput.*keys/i, /mouse_event.*button/i, /sleep.*1000.*loop/i, /thread.*while.*true/i],
              detectionMethod: 'behavioral_analysis', gameTarget: 'universal',
              description: 'Identifica patrones de automatizaci√≥n y bots de juego' },
            
            // DMA Hardware (dispositivos externos)
            { id: 'dma_hardware', name: 'DMA Hardware Detection', severity: 'MEDIUM',
              patterns: [/PCI.*device/i, /USB.*device/i, /Serial.*port/i, /Parallel.*port/i],
              detectionMethod: 'hardware_analysis', gameTarget: 'universal',
              description: 'Detecta dispositivos DMA externos utilizados para cheating' },
            
            // Debugging y bypass
            { id: 'debug_bypass', name: 'Anti-Debug/Bypass', severity: 'HIGH',
              patterns: [/IsDebuggerPresent/i, /CheckRemoteDebugger/i, /NtGlobalFlag/i],
              detectionMethod: 'anti_debug', gameTarget: 'universal',
              description: 'Identifica t√©cnicas de debugging y bypass del sistema' },
            
            // Timing manipulation
            { id: 'timing_manipulation', name: 'Timing Manipulation', severity: 'MEDIUM',
              patterns: [/QueryPerformanceCounter/i, /GetTickCount.*modify/i, /RDTSC.*instruction/i],
              detectionMethod: 'timing_analysis', gameTarget: 'universal',
              description: 'Detecta manipulaci√≥n de temporizadores del sistema' },
            
            // Game-specific patterns
            { id: 'game_specific', name: 'Game-Specific Cheats', severity: 'HIGH',
              patterns: [/aimbot.*target/i, /wallhack.*player/i, /speedhack.*velocity/i, /noclip.*collision/i],
              detectionMethod: 'game_specific', gameTarget: 'game_dependent',
              description: 'Patrones espec√≠ficos de diferentes juegos y sus cheats conocidos' }
        ];

        patterns.forEach(pattern => {
            this.cheatingPatterns.set(pattern.id, pattern);
        });
    }

    /**
     * Analiza c√≥digo con IA avanzada
     */
    analyzeCodeAdvanced(code, context = '') {
        const results = {
            riskLevel: 'LOW',
            detectedMethods: [],
            suspiciousPatterns: [],
            recommendations: [],
            confidence: 0,
            analysisTime: Date.now(),
            aiInsights: [],
            stealthAnalysis: {}
        };

        let riskScore = 0;
        let confidenceScore = 0;

        // Analizar cada patr√≥n conocido
        for (const [patternId, pattern] of this.cheatingPatterns) {
            for (const regex of pattern.patterns) {
                if (regex.test(code)) {
                    results.detectedMethods.push(pattern.name);
                    results.suspiciousPatterns.push({
                        patternId,
                        method: pattern.name,
                        regex: regex.source,
                        severity: pattern.severity,
                        detectionMethod: pattern.detectionMethod,
                        gameTarget: pattern.gameTarget,
                        description: pattern.description
                    });

                    // Calcular score de riesgo
                    switch (pattern.severity) {
                        case 'CRITICAL': riskScore += 25; break;
                        case 'HIGH': riskScore += 15; break;
                        case 'MEDIUM': riskScore += 10; break;
                        case 'LOW': riskScore += 5; break;
                    }
                    confidenceScore += 15;
                }
            }
        }

        // Determinar nivel de riesgo
        if (riskScore >= 75) results.riskLevel = 'CRITICAL';
        else if (riskScore >= 50) results.riskLevel = 'HIGH';
        else if (riskScore >= 25) results.riskLevel = 'MEDIUM';
        else if (riskScore >= 10) results.riskLevel = 'LOW';

        results.confidence = Math.min(confidenceScore, 100);

        // Generar an√°lisis espec√≠fico de Stealth-AntiCheatX
        results.stealthAnalysis = this.analyzeWithStealthContext(results);

        // Generar insights con IA
        results.aiInsights = this.generateAIInsights(results);

        // Generar recomendaciones
        results.recommendations = this.generateRecommendations(results);

        return results;
    }

    /**
     * An√°lisis espec√≠fico con contexto de Stealth-AntiCheatX
     */
    analyzeWithStealthContext(results) {
        const stealthAnalysis = {
            compatibleDetection: [],
            missingCapabilities: [],
            recommendedActions: []
        };

        // Verificar qu√© detectar√≠a Stealth-AntiCheatX
        for (const method of results.detectedMethods) {
            if (method.includes('ESP') || method.includes('Overlay')) {
                stealthAnalysis.compatibleDetection.push('Wallhacks & ESP Detection');
                stealthAnalysis.recommendedActions.push('Stealth-AntiCheatX detectar√≠a esto con window enumeration');
            }
            
            if (method.includes('DLL') || method.includes('Injection')) {
                stealthAnalysis.compatibleDetection.push('Aimbot & Process Injection');
                stealthAnalysis.recommendedActions.push('Digital signature scanning del Stealth-AntiCheatX');
            }
            
            if (method.includes('Memory')) {
                stealthAnalysis.compatibleDetection.push('Memory manipulation detection');
                stealthAnalysis.recommendedActions.push('Thread range verification y handle monitoring');
            }
            
            if (method.includes('Hardware') || method.includes('DMA')) {
                stealthAnalysis.compatibleDetection.push('DMA Hardware Detection');
                stealthAnalysis.recommendedActions.push('PCI/USB/Serial/Parallel device scanning');
            }
        }

        return stealthAnalysis;
    }

    /**
     * Genera insights usando IA simulada
     */
    generateAIInsights(results) {
        const insights = [];

        if (results.detectedMethods.includes('Memory Injection')) {
            insights.push('ü§ñ IA: Patr√≥n de inyecci√≥n de memoria detectado. Riesgo extremo para la integridad del sistema.');
        }

        if (results.detectedMethods.includes('ESP Overlay')) {
            insights.push('ü§ñ IA: Overlay ESP detectado. El usuario puede estar usando ventajas visuales.');
        }

        if (results.riskLevel === 'CRITICAL') {
            insights.push('ü§ñ IA: M√∫ltiples t√©cnicas de cheating detectadas. Se recomienda acci√≥n inmediata.');
        }

        if (results.detectedMethods.includes('DMA Hardware')) {
            insights.push('ü§ñ IA: Dispositivo DMA detectado. Posible hardware de cheating externo.');
        }

        return insights;
    }

    /**
     * Genera recomendaciones de acci√≥n
     */
    generateRecommendations(results) {
        const recommendations = [];

        if (results.riskLevel === 'CRITICAL') {
            recommendations.push('üö® ACCI√ìN INMEDIATA: Terminar procesos sospechosos');
            recommendations.push('üö® ACCI√ìN INMEDIATA: Bloquear ejecuci√≥n de c√≥digo');
        }

        if (results.detectedMethods.includes('Memory Manipulation')) {
            recommendations.push('üõ°Ô∏è RECOMENDACI√ìN: Habilitar protecci√≥n de memoria');
        }

        if (results.detectedMethods.includes('DLL Injection')) {
            recommendations.push('üõ°Ô∏è RECOMENDACI√ìN: Verificar integridad de DLLs del sistema');
        }

        if (results.detectedMethods.includes('Bot Automation')) {
            recommendations.push('üõ°Ô∏è RECOMENDACI√ìN: Implementar CAPTCHA o verificaci√≥n humana');
        }

        return recommendations;
    }

    /**
     * Escaneo profundo del sistema
     */
    async performDeepScan() {
        const threats = [];
        
        // Simulaci√≥n de escaneo profundo con conocimiento de Stealth-AntiCheatX
        for (const [threatId, threatInfo] of this.threatDatabase) {
            if (Math.random() < 0.1) { // 10% chance per threat
                threats.push({
                    id: threatId,
                    ...threatInfo,
                    timestamp: Date.now(),
                    source: 'deep_scan',
                    stealthCompatible: true
                });
            }
        }

        return threats;
    }

    /**
     * Genera reporte de an√°lisis
     */
    generateAnalysisReport(results) {
        return {
            timestamp: new Date().toISOString(),
            riskLevel: results.riskLevel,
            confidence: results.confidence,
            detectedMethods: results.detectedMethods,
            suspiciousPatterns: results.suspiciousPatterns,
            aiInsights: results.aiInsights,
            recommendations: results.recommendations,
            stealthAnalysis: results.stealthAnalysis,
            analysisId: `ANALYSIS_${Date.now()}`
        };
    }

    /**
     * Obtiene informaci√≥n completa del canal actual
     */
    getCurrentChannelInfo(channelId) {
        return this.channelKnowledge[channelId] || {
            name: 'Canal Desconocido',
            purpose: 'Canal no reconocido en la base de conocimiento',
            usage: 'Comandos b√°sicos disponibles',
            botRole: 'Asistente general'
        };
    }

    /**
     * Genera informaci√≥n completa para el comando $about
     */
    getCompleteAboutInfo() {
        return {
            systemInfo: this.stealthKnowledge,
            channels: this.channelKnowledge,
            capabilities: this.systemKnowledge,
            totalPatterns: this.cheatingPatterns.size,
            threatDatabaseSize: this.threatDatabase.size,
            currentChannel: 'CMD_CHANNEL_ID (Canal de Comandos)',
            botVersion: '4.0.0-STEALTH-COMPLETE'
        };
    }
}

// Funciones para manejar apodos
function loadNicknames() {
    try {
        if (fs.existsSync(NICKNAMES_FILE)) {
            const data = fs.readFileSync(NICKNAMES_FILE, 'utf8');
            return JSON.parse(data);
        }
    } catch (error) {
        console.log('Error loading nicknames:', error);
    }
    return {};
}

// Funciones para manejar desarrolladores
function loadDevelopers() {
    try {
        if (fs.existsSync(DEVELOPERS_FILE)) {
            const data = fs.readFileSync(DEVELOPERS_FILE, 'utf8');
            return JSON.parse(data);
        }
    } catch (error) {
        console.log('Error loading developers:', error);
    }
    return { owners: [], developers: [] };
}

function saveNicknames(nicknames) {
    try {
        fs.writeFileSync(NICKNAMES_FILE, JSON.stringify(nicknames, null, 2));
    } catch (error) {
        console.log('Error saving nicknames:', error);
    }
}

function saveDevelopers(developers) {
    try {
        fs.writeFileSync(DEVELOPERS_FILE, JSON.stringify(developers, null, 2));
    } catch (error) {
        console.log('Error saving developers:', error);
    }
}

let nicknames = loadNicknames();
let developers = loadDevelopers();

// Inicializar sistema completo Stealth-AntiCheatX
const stealthSystem = new StealthAntiCheatXSystem();

// Funciones auxiliares
function isOwner(userId) {
    return userId === BOT_OWNER_ID;
}

function isDeveloper(userId) {
    return developers.developers.includes(userId) || isOwner(userId);
}

function getUserNickname(userId, username) {
    return nicknames[userId] || username;
}

function getTotalMemberCount(client) {
    let totalMembers = 0;
    client.guilds.cache.forEach(guild => {
        totalMembers += guild.memberCount;
    });
    return totalMembers;
}

function getCurrentGuildMemberCount(client) {
    const guild = client.guilds.cache.first();
    return guild ? guild.memberCount : 0;
}

// An√°lisis de amenazas simulado
function performThreatAnalysis() {
    const threats = [
        { type: 'Procesos Sospechosos', count: Math.floor(Math.random() * 5), severity: 'medium' },
        { type: 'Conexiones de Red', count: Math.floor(Math.random() * 3), severity: 'low' },
        { type: 'Archivos Modificados', count: Math.floor(Math.random() * 2), severity: 'high' },
        { type: 'Comportamiento Anormal', count: Math.floor(Math.random() * 4), severity: 'medium' }
    ];
    return threats;
}

// Eventos del bot
client.once('ready', () => {
    console.log(`ü§ñ Stealth-AntiCheatX-Bot est√° listo!`);
    console.log(`üìç Conectado como: ${client.user.tag}`);
    console.log(`üè† En ${client.guilds.cache.size} servidores`);
    console.log(`üß† Sistema Stealth-AntiCheatX inicializado completamente`);
});

client.on('messageCreate', async (message) => {
    if (message.author.bot) return;
    
    const args = message.content.slice(BOT_PREFIX.length).trim().split(/ +/);
    const command = args.shift().toLowerCase();
    
    // Solo responder en canales espec√≠ficos o si es mencionado
    const allowedChannels = [CMD_CHANNEL_ID, SUPPORT_CHANNEL_ID, DESCUBRIMIENTOS_CHANNEL_ID, IMPLEMENTACIONES_CHANNEL_ID, CHAT_CHANNEL_ID];
    const isAllowedChannel = allowedChannels.includes(message.channel.id);
    const isMentioned = message.mentions.has(client.user);
    
    if (!isAllowedChannel && !isMentioned && !command) return;

    try {
        switch (command) {
            case 'ping':
                const pingEmbed = new EmbedBuilder()
                    .setTitle('üèì Pong!')
                    .addFields(
                        { name: 'üíì Latencia del Bot', value: `${client.ws.ping}ms`, inline: true },
                        { name: 'üì° Latencia de API', value: `${Date.now() - message.createdTimestamp}ms`, inline: true }
                    )
                    .setColor('#00ff00');
                await message.reply({ embeds: [pingEmbed] });
                break;

            case 'help':
                const helpEmbed = new EmbedBuilder()
                    .setTitle('üìã Lista de Comandos')
                    .addFields(
                        { name: 'üìã Comandos B√°sicos', value: `\`${BOT_PREFIX}help\` - Lista de comandos\n\`${BOT_PREFIX}ping\` - Verificar estado\n\`${BOT_PREFIX}scan\` - Escanear servidor`, inline: true },
                        { name: 'üõ°Ô∏è Stealth-AntiCheatX', value: `\`${BOT_PREFIX}anticheat info\` - Info detallada\n\`${BOT_PREFIX}anticheat scan\` - Escaneo profundo\n\`${BOT_PREFIX}anticheat patterns\` - Patrones\n\`${BOT_PREFIX}anticheat stealth\` - Sistema completo`, inline: true },
                        { name: 'üë®‚Äçüíª Desarrolladores', value: `\`${BOT_PREFIX}dev status\` - Status sistema\n\`${BOT_PREFIX}dev analyze [c√≥digo]\` - An√°lisis\n\`${BOT_PREFIX}dev channels\` - Info canales`, inline: true }
                    )
                    .setFooter({ text: `Prefijo: ${BOT_PREFIX}` })
                    .setColor('#0099ff');
                await message.reply({ embeds: [helpEmbed] });
                break;

            case 'about':
                const aboutInfo = stealthSystem.getCompleteAboutInfo();
                const currentChannelInfo = stealthSystem.getCurrentChannelInfo(message.channel.id);
                
                const aboutEmbed = new EmbedBuilder()
                    .setTitle('ü§ñ Acerca de Stealth-AntiCheatX-Bot')
                    .setDescription('Bot especializado en detecci√≥n de cheating con conocimiento completo del sistema Stealth-AntiCheatX')
                    .addFields(
                        { name: 'üîß Versi√≥n', value: aboutInfo.botVersion, inline: true },
                        { name: 'üß† Sistema Base', value: 'Stealth-AntiCheatX v2.1.0', inline: true },
                        { name: 'üë®‚Äçüíª Desarrollador', value: aboutInfo.systemInfo.developer, inline: true },
                        { name: 'üìã Patrones Detectados', value: aboutInfo.totalPatterns.toString(), inline: true },
                        { name: 'üóÉÔ∏è Base de Amenazas', value: aboutInfo.threatDatabaseSize.toString(), inline: true },
                        { name: 'üìÖ Copyright', value: aboutInfo.systemInfo.copyright, inline: true }
                    )
                    .addFields(
                        { name: 'üìç Canal Actual', value: `${currentChannelInfo.name}\n${currentChannelInfo.purpose}`, inline: false },
                        { name: 'üõ°Ô∏è Categor√≠as de Detecci√≥n', value: Object.keys(aboutInfo.capabilities.detectionCategories).length.toString(), inline: true },
                        { name: '‚öôÔ∏è Funciones de Protecci√≥n', value: Object.keys(aboutInfo.capabilities.protectionFunctionalities).length.toString(), inline: true },
                        { name: 'üéØ Plataforma Objetivo', value: aboutInfo.systemInfo.targetPlatform, inline: true }
                    )
                    .addFields(
                        { name: 'üé™ Uso de Canales', value: 
                            `**${stealthSystem.channelKnowledge[CMD_CHANNEL_ID]?.name}**: Comandos del bot\n` +
                            `**${stealthSystem.channelKnowledge[SUPPORT_CHANNEL_ID]?.name}**: Soporte t√©cnico\n` +
                            `**${stealthSystem.channelKnowledge[DESCUBRIMIENTOS_CHANNEL_ID]?.name}**: Hallazgos y an√°lisis\n` +
                            `**${stealthSystem.channelKnowledge[IMPLEMENTACIONES_CHANNEL_ID]?.name}**: Implementaciones\n` +
                            `**${stealthSystem.channelKnowledge[CHAT_CHANNEL_ID]?.name}**: Chat general`, inline: false }
                    )
                    .setColor('#7289da')
                    .setFooter({ text: `Bot desarrollado por ${aboutInfo.systemInfo.developer}` });
                await message.reply({ embeds: [aboutEmbed] });
                break;

            case 'scan':
                // Simulaci√≥n de escaneo del servidor
                const threats = performThreatAnalysis();
                const totalThreats = threats.reduce((sum, threat) => sum + threat.count, 0);

                const scanEmbed = new EmbedBuilder()
                    .setTitle('üîç Escaneando Servidor...')
                    .addFields(
                        { name: 'üë• Miembros Escaneados', value: `${getCurrentGuildMemberCount(client)}`, inline: true },
                        { name: 'üõ°Ô∏è Amenazas Encontradas', value: totalThreats.toString(), inline: true },
                        { name: 'üìä An√°lisis', value: threats.map(t => `‚Ä¢ ${t.type}: ${t.count} (${t.severity})`).join('\n') || '‚úÖ Sin problemas detectados', inline: false }
                    )
                    .setColor('#ff9900');
                
                await message.reply({ embeds: [scanEmbed] });

                // Notificaci√≥n de escaneo completado
                const guild = message.guild;
                if (ANTICHEAT_WEBHOOK_URL && guild) {
                    const webhookPayload = {
                        content: null,
                        embeds: [{
                            title: 'üîç Nuevo Escaneo Realizado',
                            description: `Se complet√≥ un escaneo del servidor ${guild.name}`,
                            color: 0x00ff00,
                            fields: [
                                { name: 'üîç Miembros', value: getCurrentGuildMemberCount(client).toString(), inline: true },
                                { name: 'üö® Amenazas', value: totalThreats.toString(), inline: true }
                            ],
                            timestamp: new Date().toISOString()
                        }]
                    };
                    
                    try {
                        await fetch(ANTICHEAT_WEBHOOK_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(webhookPayload)
                        });
                    } catch (error) {
                        console.log('Error enviando webhook:', error);
                    }
                }
                break;

            case 'anticheat':
                const anticheatSubcommand = args[0];
                
                switch (anticheatSubcommand) {
                    case 'info':
                        const infoEmbed = new EmbedBuilder()
                            .setTitle('üõ°Ô∏è Stealth-AntiCheatX - Informaci√≥n Completa')
                            .setDescription('Sistema anti-cheat especializado con detecci√≥n avanzada por IA y conocimiento completo')
                            .addFields(
                                { name: 'ü§ñ Desarrollador', value: stealthSystem.stealthKnowledge.developer, inline: true },
                                { name: 'üîß Versi√≥n Sistema', value: stealthSystem.stealthKnowledge.version, inline: true },
                                { name: 'üìã Plataforma', value: stealthSystem.stealthKnowledge.targetPlatform, inline: true },
                                { name: 'üß† Patrones Detectados', value: stealthSystem.cheatingPatterns.size.toString(), inline: true },
                                { name: 'üóÉÔ∏è Base de Datos', value: stealthSystem.threatDatabase.size.toString(), inline: true },
                                { name: 'üìÖ Copyright', value: stealthSystem.stealthKnowledge.copyright, inline: true }
                            )
                            .addFields(
                                { name: 'üéØ M√©todos Principales', value: 
                                    '‚Ä¢ Memory Injection & ESP Detection\n' +
                                    '‚Ä¢ DLL Injection & Process Monitoring\n' +
                                    '‚Ä¢ DMA Hardware Detection\n' +
                                    '‚Ä¢ Time Manipulation Analysis\n' +
                                    '‚Ä¢ File Integrity Verification', inline: false }
                            )
                            .addFields(
                                { name: '‚ö° Funciones Avanzadas', value: 
                                    '‚Ä¢ An√°lisis en tiempo real con IA\n' +
                                    '‚Ä¢ Detecci√≥n de patrones m√∫ltiples\n' +
                                    '‚Ä¢ Alertas autom√°ticas contextuales\n' +
                                    '‚Ä¢ Auto-actualizaci√≥n de firmas\n' +
                                    '‚Ä¢ Integraci√≥n Discord completa', inline: false }
                            )
                            .setColor('#00ff00')
                            .setFooter({ text: 'Stealth-AntiCheatX System v2.1.0' });
                        await message.reply({ embeds: [infoEmbed] });
                        break;

                    case 'scan':
                        const scanProgressEmbed = new EmbedBuilder()
                            .setTitle('üß† Escaneo Stealth-AntiCheatX Avanzado')
                            .setDescription('Ejecutando an√°lisis profundo con conocimiento completo del sistema...')
                            .addFields(
                                { name: 'üîç Estado', value: 'Escaneando...', inline: true },
                                { name: 'üõ°Ô∏è Nivel', value: 'STEALTH COMPLETO', inline: true },
                                { name: '‚è±Ô∏è Tiempo', value: 'En progreso...', inline: true }
                            )
                            .setColor('#ff6600');
                        
                        const scanMessage = await message.reply({ embeds: [scanProgressEmbed] });

                        // Simular escaneo avanzado con contexto de Stealth
                        setTimeout(async () => {
                            const deepThreats = await stealthSystem.performDeepScan();
                            const analysisResults = stealthSystem.analyzeCodeAdvanced('// Stealth-AntiCheatX compatible analysis');
                            
                            const resultsEmbed = new EmbedBuilder()
                                .setTitle('‚úÖ Escaneo Stealth-AntiCheatX Completado')
                                .setDescription('An√°lisis completo con conocimiento del sistema finalizado')
                                .addFields(
                                    { name: 'üö® Amenazas Detectadas', value: deepThreats.length.toString(), inline: true },
                                    { name: 'üõ°Ô∏è Nivel de Riesgo', value: analysisResults.riskLevel, inline: true },
                                    { name: 'ü§ñ Confianza IA', value: `${analysisResults.confidence}%`, inline: true },
                                    { name: 'üéØ Patrones Analizados', value: analysisResults.detectedMethods.length.toString(), inline: true }
                                )
                                .addFields(
                                    { name: 'üîç Compatibilidad Stealth', value: 
                                        analysisResults.stealthAnalysis.compatibleDetection.length > 0 
                                            ? analysisResults.stealthAnalysis.compatibleDetection.join(', ')
                                            : 'No aplicable', 
                                      inline: false }
                                )
                                .setColor(analysisResults.riskLevel === 'CRITICAL' ? '#ff0000' : 
                                         analysisResults.riskLevel === 'HIGH' ? '#ff6600' : '#00ff00');

                            // Agregar insights de IA
                            if (analysisResults.aiInsights.length > 0) {
                                resultsEmbed.addFields({
                                    name: 'ü§ñ Insights de IA',
                                    value: analysisResults.aiInsights.join('\n'),
                                    inline: false
                                });
                            }

                            await scanMessage.edit({ embeds: [resultsEmbed] });
                        }, 3000);
                        break;

                    case 'patterns':
                        const patternsEmbed = new EmbedBuilder()
                            .setTitle('üß† Patrones de Detecci√≥n Stealth-AntiCheatX')
                            .setDescription('Base de datos completa de patrones de cheating con contexto del sistema')
                            .addFields(
                                { name: 'üìä Total de Patrones', value: stealthSystem.cheatingPatterns.size.toString(), inline: true },
                                { name: 'üö® Nivel Cr√≠tico', value: Array.from(stealthSystem.cheatingPatterns.values()).filter(p => p.severity === 'CRITICAL').length.toString(), inline: true },
                                { name: '‚ö†Ô∏è Nivel Alto', value: Array.from(stealthSystem.cheatingPatterns.values()).filter(p => p.severity === 'HIGH').length.toString(), inline: true },
                                { name: 'üõ°Ô∏è Categor√≠as Stealth', value: Object.keys(stealthSystem.systemKnowledge.detectionCategories).length.toString(), inline: true }
                            )
                            .setColor('#0066cc');

                        // Mostrar algunos patrones espec√≠ficos con descripci√≥n
                        const criticalPatterns = Array.from(stealthSystem.cheatingPatterns.values())
                            .filter(p => p.severity === 'CRITICAL')
                            .slice(0, 4);

                        if (criticalPatterns.length > 0) {
                            patternsEmbed.addFields({
                                name: 'üî• Patrones Cr√≠ticos (Top)',
                                value: criticalPatterns.map(p => 
                                    `**${p.name}** (${p.detectionMethod})\n${p.description}`
                                ).join('\n\n'),
                                inline: false
                            });
                        }

                        await message.reply({ embeds: [patternsEmbed] });
                        break;

                    case 'stealth':
                        const stealthEmbed = new EmbedBuilder()
                            .setTitle('üõ°Ô∏è Sistema Stealth-AntiCheatX Completo')
                            .setDescription('Conocimiento completo del sistema con todas sus funcionalidades')
                            .addFields(
                                { name: 'üéØ Plataforma Objetivo', value: stealthSystem.stealthKnowledge.targetPlatform, inline: true },
                                { name: 'üíª SO Requerido', value: stealthSystem.systemKnowledge.usageRequirements.operatingSystem, inline: true },
                                { name: 'üîß Desarrollo', value: stealthSystem.systemKnowledge.usageRequirements.development, inline: true },
                                { name: 'üîê Privilegios', value: stealthSystem.systemUsageRequirements?.privileges || 'Administrator & SE_DEBUG', inline: true }
                            )
                            .addFields(
                                { name: 'üîç Categor√≠as de Detecci√≥n', value: Object.keys(stealthSystem.systemKnowledge.detectionCategories).map(cat => 
                                    `‚Ä¢ ${stealthSystem.systemKnowledge.detectionCategories[cat].name}`).join('\n'), inline: false }
                            )
                            .addFields(
                                { name: '‚öôÔ∏è Funciones de Protecci√≥n', value: Object.keys(stealthSystem.systemKnowledge.protectionFunctionalities).map(func => 
                                    `‚Ä¢ ${stealthSystem.systemKnowledge.protectionFunctionalities[func].name}`).join('\n'), inline: false }
                            )
                            .addFields(
                                { name: 'üîä Alertas de Audio', value: 
                                    '‚Ä¢ ESP: Beep 1000Hz\n' +
                                    '‚Ä¢ DLLs: Beep 800Hz\n' +
                                    '‚Ä¢ Threads: Beep 600Hz\n' +
                                    '‚Ä¢ Time: Beep 750Hz', inline: false }
                            )
                            .setColor('#4b0082')
                            .setFooter({ text: `Licencia: ${stealthSystem.stealthKnowledge.license}` });
                        await message.reply({ embeds: [stealthEmbed] });
                        break;

                    case 'channels':
                        const channelsEmbed = new EmbedBuilder()
                            .setTitle('üìã Sistema de Canales Stealth')
                            .setDescription('Conocimiento completo del uso de canales espec√≠ficos')
                            .addFields(
                                { name: 'üìù Comando', value: `\`${BOT_PREFIX}anticheat channels\``, inline: true },
                                { name: 'üéØ Canal Actual', value: stealthSystem.getCurrentChannelInfo(message.channel.id).name, inline: true },
                                { name: 'üìç Prop√≥sito', value: stealthSystem.getCurrentChannelInfo(message.channel.id).purpose, inline: true }
                            )
                            .addFields(
                                { name: 'üéÆ Canales Especializados', value: 
                                    `**${stealthSystem.channelKnowledge[CMD_CHANNEL_ID]?.name}**: Comandos del bot\n` +
                                    `**${stealthSystem.channelKnowledge[SUPPORT_CHANNEL_ID]?.name}**: Soporte t√©cnico\n` +
                                    `**${stealthSystem.channelKnowledge[DESCUBRIMIENTOS_CHANNEL_ID]?.name}**: Descubrimientos\n` +
                                    `**${stealthSystem.channelKnowledge[IMPLEMENTACIONES_CHANNEL_ID]?.name}**: Implementaciones\n` +
                                    `**${stealthSystem.channelKnowledge[CHAT_CHANNEL_ID]?.name}**: Chat general`, inline: false }
                            )
                            .setColor('#ff6b35');
                        await message.reply({ embeds: [channelsEmbed] });
                        break;

                    default:
                        const defaultAnticheatEmbed = new EmbedBuilder()
                            .setTitle('üõ°Ô∏è Comando Stealth-AntiCheatX')
                            .setDescription('Use uno de los subcomandos especializados:')
                            .addFields(
                                { name: '‚ÑπÔ∏è Informaci√≥n General', value: `\`${BOT_PREFIX}anticheat info\``, inline: true },
                                { name: 'üîç Escaneo Avanzado', value: `\`${BOT_PREFIX}anticheat scan\``, inline: true },
                                { name: 'üß† Ver Patrones', value: `\`${BOT_PREFIX}anticheat patterns\``, inline: true },
                                { name: 'üõ°Ô∏è Sistema Completo', value: `\`${BOT_PREFIX}anticheat stealth\``, inline: true },
                                { name: 'üìã Sistema de Canales', value: `\`${BOT_PREFIX}anticheat channels\``, inline: true }
                            )
                            .setColor('#0099ff');
                        await message.reply({ embeds: [defaultAnticheatEmbed] });
                }
                break;

            // ========================================
            // üßë‚Äçüíª COMANDOS PARA DESARROLLADORES
            // ========================================

            case 'dev':
                if (!isDeveloper(message.author.id)) {
                    await message.reply('‚ùå **ACCESO DENEGADO**: Este comando es solo para desarrolladores.');
                    return;
                }

                const devSubcommand = args[0];
                
                switch (devSubcommand) {
                    case 'status':
                        const devStatusEmbed = new EmbedBuilder()
                            .setTitle('üë®‚Äçüíª Status Sistema Stealth-AntiCheatX')
                            .addFields(
                                { name: 'ü§ñ Bot', value: `Online ‚úÖ\nPing: ${client.ws.ping}ms`, inline: true },
                                { name: 'üß† IA Anti-Cheat', value: `Patrones: ${stealthSystem.cheatingPatterns.size}\nAmenazas: ${stealthSystem.threatDatabase.size}`, inline: true },
                                { name: 'üìä An√°lisis', value: `Historial: ${stealthSystem.analysisHistory.length}`, inline: true },
                                { name: 'üõ°Ô∏è Sistema Stealth', value: `Conocimiento: Completo\nVersi√≥n: ${stealthSystem.stealthKnowledge.version}`, inline: true },
                                { name: 'üìç Canal Actual', value: stealthSystem.getCurrentChannelInfo(message.channel.id).name, inline: true }
                            )
                            .setColor('#00ff00')
                            .setFooter({ text: `Modo Desarrollador Stealth-AntiCheatX Activado` });
                        await message.reply({ embeds: [devStatusEmbed] });
                        break;

                    case 'channels':
                        const channelInfoEmbed = new EmbedBuilder()
                            .setTitle('üìã Informaci√≥n de Canales')
                            .setDescription('Conocimiento detallado del sistema de canales especializados')
                            .addFields(
                                { name: 'üéØ Canal Actual', value: `${stealthSystem.getCurrentChannelInfo(message.channel.id).name}`, inline: false },
                                { name: 'üìù Prop√≥sito', value: stealthSystem.getCurrentChannelInfo(message.channel.id).purpose, inline: false },
                                { name: 'üí¨ Uso', value: stealthSystem.getCurrentChannelInfo(message.channel.id).usage, inline: false },
                                { name: 'ü§ñ Rol del Bot', value: stealthSystem.getCurrentChannelInfo(message.channel.id).botRole, inline: false }
                            )
                            .addFields(
                                { name: 'üé™ Todos los Canales', value: 
                                    `**CMD**: Comandos y consultas t√©cnicas\n` +
                                    `**Soporte**: Asistencia y resoluci√≥n de problemas\n` +
                                    `**Descubrimientos**: Hallazgos y an√°lisis\n` +
                                    `**Implementaciones**: Nuevas funciones y mejoras\n` +
                                    `**Chat**: Conversaci√≥n libre`, inline: false }
                            )
                            .setColor('#9b59b6');
                        await message.reply({ embeds: [channelInfoEmbed] });
                        break;

                    case 'move':
                        const targetChannelName = args[1];
                        if (!targetChannelName) {
                            await message.reply('‚ùå **Error**: Especifica el nombre del canal\nüìù **Uso**: `dev move [nombre_canal]`');
                            return;
                        }

                        // Buscar canal por nombre
                        const targetChannel = message.guild.channels.cache.find(
                            channel => channel.type === 0 && channel.name.toLowerCase().includes(targetChannelName.toLowerCase())
                        );

                        if (!targetChannel) {
                            await message.reply(`‚ùå **Error**: No se encontr√≥ el canal "${targetChannelName}"`);
                            return;
                        }

                        // Enviar mensaje al canal objetivo
                        const moveEmbed = new EmbedBuilder()
                            .setTitle('ü§ñ Bot Stealth-AntiCheatX')
                            .setDescription(`‚úÖ He cambiado al canal **${targetChannel.name}** como solicitaste`)
                            .addFields(
                                { name: 'üìç Canal Anterior', value: message.channel.name, inline: true },
                                { name: 'üéØ Canal Nuevo', value: targetChannel.name, inline: true },
                                { name: 'üïí Cambio', value: new Date().toLocaleTimeString(), inline: true }
                            )
                            .setColor('#00ff00');

                        try {
                            await targetChannel.send({ embeds: [moveEmbed] });
                            await message.reply(`‚úÖ **Cambiado exitosamente** al canal ${targetChannel}`);
                        } catch (error) {
                            console.error('Error al cambiar de canal:', error);
                            await message.reply('‚ùå **Error**: No se pudo enviar el mensaje al canal objetivo.');
                        }
                        break;

                    case 'update':
                        const updateType = args[1];
                        
                        switch (updateType) {
                            case 'patterns':
                                stealthSystem.initializePatterns();
                                await message.reply('‚úÖ **Patrones de detecci√≥n Stealth-AntiCheatX actualizados**');
                                break;
                                
                            case 'threats':
                                stealthSystem.initializeThreatDatabase?.();
                                await message.reply('‚úÖ **Base de datos de amenazas actualizada**');
                                break;
                                
                            case 'knowledge':
                                stealthSystem.initializeKnowledgeBase();
                                await message.reply('‚úÖ **Base de conocimientos Stealth-AntiCheatX actualizada**');
                                break;
                                
                            case 'all':
                                stealthSystem.initializePatterns();
                                stealthSystem.initializeThreatDatabase?.();
                                stealthSystem.initializeKnowledgeBase();
                                await message.reply('‚úÖ **Sistema Stealth-AntiCheatX completamente actualizado**');
                                break;
                                
                            default:
                                await message.reply('üìù **Uso**: `dev update [patterns|threats|knowledge|all]`');
                        }
                        break;

                    case 'analyze':
                        const codeToAnalyze = args.slice(1).join(' ');
                        if (!codeToAnalyze) {
                            await message.reply('‚ùå **Error**: Proporciona c√≥digo para analizar\nüìù **Uso**: `dev analyze [c√≥digo]`');
                            return;
                        }

                        const analysisResults = stealthSystem.analyzeCodeAdvanced(codeToAnalyze);
                        const analysisEmbed = new EmbedBuilder()
                            .setTitle('üî¨ An√°lisis Stealth-AntiCheatX de C√≥digo')
                            .addFields(
                                { name: 'üõ°Ô∏è Nivel de Riesgo', value: analysisResults.riskLevel, inline: true },
                                { name: 'ü§ñ Confianza', value: `${analysisResults.confidence}%`, inline: true },
                                { name: 'üéØ M√©todos Detectados', value: analysisResults.detectedMethods.length.toString(), inline: true }
                            )
                            .setColor(analysisResults.riskLevel === 'CRITICAL' ? '#ff0000' : 
                                     analysisResults.riskLevel === 'HIGH' ? '#ff6600' : '#00ff00');

                        if (analysisResults.detectedMethods.length > 0) {
                            analysisEmbed.addFields({
                                name: 'üö® M√©todos de Cheating',
                                value: analysisResults.detectedMethods.join(', '),
                                inline: false
                            });
                        }

                        if (analysisResults.stealthAnalysis.compatibleDetection.length > 0) {
                            analysisEmbed.addFields({
                                name: 'üõ°Ô∏è Compatibilidad Stealth-AntiCheatX',
                                value: analysisResults.stealthAnalysis.compatibleDetection.join('\n'),
                                inline: false
                            });
                        }

                        if (analysisResults.aiInsights.length > 0) {
                            analysisEmbed.addFields({
                                name: 'ü§ñ Insights de IA',
                                value: analysisResults.aiInsights.join('\n'),
                                inline: false
                            });
                        }

                        if (analysisResults.recommendations.length > 0) {
                            analysisEmbed.addFields({
                                name: 'üõ°Ô∏è Recomendaciones',
                                value: analysisResults.recommendations.join('\n'),
                                inline: false
                            });
                        }

                        await message.reply({ embeds: [analysisEmbed] });
                        break;

                    case 'test':
                        const testResults = stealthSystem.analyzeCodeAdvanced(`
                            VirtualAllocEx(GetCurrentProcess(), NULL, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
                            CreateRemoteThread(GetCurrentProcess(), NULL, 0, (LPTHREAD_START_ROUTINE)shellcode, NULL, 0, NULL);
                            GetWindowLongPtr(espWindow, GWL_EXSTYLE);
                        `);

                        const testEmbed = new EmbedBuilder()
                            .setTitle('üß™ Test Stealth-AntiCheatX - Memory Injection + ESP')
                            .addFields(
                                { name: '‚úÖ Estado', value: 'DETECTADO COMPLETAMENTE', inline: true },
                                { name: 'üõ°Ô∏è Riesgo', value: testResults.riskLevel, inline: true },
                                { name: 'ü§ñ Confianza', value: `${testResults.confidence}%`, inline: true }
                            )
                            .addFields(
                                { name: 'üîç M√©todos Detectados', value: testResults.detectedMethods.join(', '), inline: false }
                            )
                            .setColor('#ff0000');

                        await message.reply({ embeds: [testEmbed] });
                        break;

                    case 'mode':
                        const newMode = args[1];
                        
                        if (newMode === 'on') {
                            stealthSystem.devMode = true;
                            await message.reply('‚úÖ **Modo Desarrollador Stealth-AntiCheatX ACTIVADO** - Acceso completo a funciones avanzadas');
                        } else if (newMode === 'off') {
                            stealthSystem.devMode = false;
                            await message.reply('‚úÖ **Modo Desarrollador Stealth-AntiCheatX DESACTIVADO** - Funciones b√°sicas activadas');
                        } else {
                            await message.reply(`üìä **Estado Actual**: ${stealthSystem.devMode ? 'ACTIVADO' : 'DESACTIVADO'}\nüìù **Uso**: dev mode [on|off]`);
                        }
                        break;

                    case 'help':
                        const devHelpEmbed = new EmbedBuilder()
                            .setTitle('üë®‚Äçüíª Comandos Stealth-AntiCheatX para Desarrolladores')
                            .addFields(
                                { name: 'üìä Status del Sistema', value: `\`${BOT_PREFIX}dev status\``, inline: true },
                                { name: 'üìã Informaci√≥n de Canales', value: `\`${BOT_PREFIX}dev channels\``, inline: true },
                                { name: 'üîÑ Actualizar Base de Datos', value: `\`${BOT_PREFIX}dev update [patterns|threats|knowledge|all]\``, inline: true },
                                { name: 'üî¨ Analizar C√≥digo', value: `\`${BOT_PREFIX}dev analyze [c√≥digo]\``, inline: true },
                                { name: 'üß™ Test de Detecci√≥n', value: `\`${BOT_PREFIX}dev test\``, inline: true },
                                { name: '‚öôÔ∏è Modo Desarrollador', value: `\`${BOT_PREFIX}dev mode [on|off]\``, inline: true },
                                { name: 'üöÄ Mover Bot', value: `\`${BOT_PREFIX}dev move [nombre_canal]\``, inline: true }
                            )
                            .setColor('#0066cc')
                            .setFooter({ text: 'Solo disponible para desarrolladores autorizados de Stealth-AntiCheatX' });
                        await message.reply({ embeds: [devHelpEmbed] });
                        break;

                    default:
                        const defaultDevEmbed = new EmbedBuilder()
                            .setTitle('üë®‚Äçüíª Panel Desarrollador Stealth-AntiCheatX')
                            .setDescription('Comandos especializados para gesti√≥n del sistema anti-cheat completo')
                            .addFields(
                                { name: 'üìã Lista de Comandos', value: `\`${BOT_PREFIX}dev help\` - Ver todos los comandos`, inline: true },
                                { name: 'üîß Estado del Sistema', value: `\`${BOT_PREFIX}dev status\` - Informaci√≥n detallada`, inline: true },
                                { name: 'üìç Info Canales', value: `\`${BOT_PREFIX}dev channels\` - Conocimiento de canales`, inline: true },
                                { name: '‚öôÔ∏è Control', value: `\`${BOT_PREFIX}dev mode on/off\` - Activar/desactivar modo dev`, inline: true },
                                { name: 'üöÄ Mover Bot', value: `\`${BOT_PREFIX}dev move [canal]\` - Cambiar canal actual`, inline: true }
                            )
                            .setColor('#00ff00')
                            .setFooter({ text: `Desarrollador Stealth: ${message.author.username}` });
                        await message.reply({ embeds: [defaultDevEmbed] });
                }
                break;

            case 'vc':
                const voiceChannel = message.member.voice.channel;
                if (!voiceChannel) {
                    await message.reply('‚ùå **Error**: Necesitas estar conectado a un canal de voz para usar este comando.');
                    return;
                }

                if (args.length > 0) {
                    // El usuario quiere que el bot se una a un canal espec√≠fico
                    const targetChannelName = args.join(' ');
                    const targetChannel = message.guild.channels.cache.find(
                        channel => channel.type === 2 && channel.name.toLowerCase().includes(targetChannelName.toLowerCase())
                    );

                    if (!targetChannel) {
                        await message.reply('‚ùå **Error**: No se encontr√≥ el canal de voz especificado.');
                        return;
                    }

                    // Verificar si el usuario est√° en un canal de voz
                    if (!message.member.voice.channel) {
                        await message.reply('‚ùå **Error**: Debes estar en un canal de voz para que el bot se una.');
                        return;
                    }

                    try {
                        // Si el bot ya est√° conectado, cambiar de canal
                        if (message.guild.members.me.voice.channel) {
                            await message.guild.members.me.voice.setChannel(targetChannel.id);
                        } else {
                            // Si el bot no est√° conectado, conectarse al canal del usuario primero
                            await message.guild.members.me.voice.setChannel(message.member.voice.channel.id);
                            // Luego cambiar al canal deseado
                            setTimeout(async () => {
                                await message.guild.members.me.voice.setChannel(targetChannel.id);
                            }, 1000);
                        }

                        const vcEmbed = new EmbedBuilder()
                            .setTitle('üéµ Uni√©ndose a Canal de Voz')
                            .setDescription(`‚úÖ Conectado a **${targetChannel.name}**`)
                            .addFields(
                                { name: 'üìç Canal', value: targetChannel.name, inline: true },
                                { name: 'üë• Usuarios', value: targetChannel.members.size.toString(), inline: true }
                            )
                            .setColor('#00ff00');
                        await message.reply({ embeds: [vcEmbed] });
                    } catch (error) {
                        console.error('Error al conectar al canal de voz:', error);
                        await message.reply('‚ùå **Error**: No se pudo conectar al canal de voz.');
                    }
                } else {
                    // Mostrar informaci√≥n del canal actual del usuario
                    if (voiceChannel) {
                        const currentVcEmbed = new EmbedBuilder()
                            .setTitle('üéµ Informaci√≥n del Canal de Voz')
                            .addFields(
                                { name: 'üìç Canal', value: voiceChannel.name, inline: true },
                                { name: 'üë• Usuarios Conectados', value: voiceChannel.members.size.toString(), inline: true },
                                { name: 'üîä Bitrate', value: `${voiceChannel.bitrate / 1000}kbps`, inline: true }
                            )
                            .setColor('#0099ff');
                        await message.reply({ embeds: [currentVcEmbed] });
                    } else {
                        await message.reply('‚ùå **Error**: No est√°s conectado a ning√∫n canal de voz.');
                    }
                }
                break;

            case 'community':
                const communityEmbed = new EmbedBuilder()
                    .setTitle('üåü Community Stealth Gaming')
                    .setDescription('¬°√önete a nuestra comunidad especializada en Stealth-AntiCheatX!')
                    .addFields(
                        { name: 'üîó Invitaci√≥n', value: `[Unirse al Servidor](${COMMUNITY_SERVER_INVITE})`, inline: true },
                        { name: 'üõ°Ô∏è Especialidad', value: 'Stealth-AntiCheatX Completo', inline: true },
                        { name: 'üë• Miembros', value: 'Comunidad Activa', inline: true }
                    )
                    .setColor('#7289da');
                await message.reply({ embeds: [communityEmbed] });
                break;

            case 'add_server':
                const inviteLink = `https://discord.com/api/oauth2/authorize?client_id=${client.user.id}&permissions=8&scope=bot%20applications.commands`;
                const addServerEmbed = new EmbedBuilder()
                    .setTitle('‚ûï Invitar Bot Stealth-AntiCheatX')
                    .setDescription('¬°Agrega Stealth-AntiCheatX-Bot a tu servidor!')
                    .addFields(
                        { name: 'üîó Link de Invitaci√≥n', value: `[Click aqu√≠ para invitar](${inviteLink})`, inline: false }
                    )
                    .setColor('#00ff00');
                await message.reply({ embeds: [addServerEmbed] });
                break;

            case 'canales':
                const canales = message.guild.channels.cache
                    .filter(channel => channel.type === 0) // Solo canales de texto
                    .map(channel => `<#${channel.id}>`)
                    .join('\n');

                const canalesEmbed = new EmbedBuilder()
                    .setTitle('üìã Canales del Servidor')
                    .setDescription(canales || 'No se encontraron canales de texto.')
                    .setColor('#7289da');
                await message.reply({ embeds: [canalesEmbed] });
                break;

            case 'status':
                // An√°lisis avanzado de amenazas para status
                const threatAnalysis = performThreatAnalysis();
                const totalThreatsAnalysis = threatAnalysis.reduce((sum, threat) => sum + threat.count, 0);
                
                const statusEmbed = new EmbedBuilder()
                    .setTitle('üìä Status Sistema Stealth-AntiCheatX')
                    .addFields(
                        { name: 'ü§ñ Estado del Bot', value: 'Online ‚úÖ', inline: true },
                        { name: 'üõ°Ô∏è Nivel de Amenaza', value: totalThreatsAnalysis > 5 ? 'ALTO' : 'NORMAL', inline: true },
                        { name: 'üìä Amenazas Detectadas', value: totalThreatsAnalysis.toString(), inline: true },
                        { name: 'üë• Servidores', value: client.guilds.cache.size.toString(), inline: true },
                        { name: '‚è∞ Uptime', value: `${Math.floor(process.uptime() / 3600)}h ${Math.floor((process.uptime() % 3600) / 60)}m`, inline: true },
                        { name: 'üíì Latencia', value: `${client.ws.ping}ms`, inline: true },
                        { name: 'üß† Sistema', value: 'Stealth-AntiCheatX v2.1.0', inline: true },
                        { name: 'üìç Canal Actual', value: stealthSystem.getCurrentChannelInfo(message.channel.id).name, inline: true }
                    )
                    .setColor(totalThreatsAnalysis > 5 ? '#ff0000' : '#00ff00');
                await message.reply({ embeds: [statusEmbed] });
                break;

        }
    } catch (error) {
        console.error('Error ejecutando comando:', error);
        await message.reply('‚ùå **Error**: Ocurri√≥ un problema ejecutando el comando.');
    }
});

// Iniciar el bot
client.login(process.env.DISCORD_BOT_TOKEN);