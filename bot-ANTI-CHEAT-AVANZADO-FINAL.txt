require('dotenv').config();
const { Client, GatewayIntentBits, EmbedBuilder, AttachmentBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const fs = require('fs');
const path = require('path');

// ConfiguraciÃ³n del bot
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildMembers,
        GatewayIntentBits.GuildPresences,
        GatewayIntentBits.GuildVoiceStates
    ]
});

// Variables de configuraciÃ³n
const BOT_PREFIX = process.env.BOT_PREFIX || '$';
const BOT_OWNER_ID = process.env.BOT_OWNER_ID;
const SUPPORT_CHANNEL_ID = process.env.SUPPORT_CHANNEL_ID;
const DESCUBRIMIENTOS_CHANNEL_ID = process.env.DESCUBRIMIENTOS_CHANNEL_ID;
const IMPLEMENTACIONES_CHANNEL_ID = process.env.IMPLEMENTACIONES_CHANNEL_ID;
const CHAT_CHANNEL_ID = process.env.CHAT_CHANNEL_ID;
const CMD_CHANNEL_ID = process.env.CMD_CHANNEL_ID;
const ANTICHEAT_WEBHOOK_URL = process.env.ANTICHEAT_WEBHOOK_URL;
const COMMUNITY_SERVER_INVITE = process.env.COMMUNITY_SERVER_INVITE || 'https://discord.gg/stealth-anticheat';

// Base de datos de apodos
const NICKNAMES_FILE = path.join(__dirname, 'nicknames.json');
const DEVELOPERS_FILE = path.join(__dirname, 'developers.json');
const ANTI_CHEAT_DB = path.join(__dirname, 'anti_cheat_analysis.db');

// ========================================
// ğŸ§  CLASE ANTI-CHEAT AVANZADA
// ========================================

class AdvancedAntiCheatAnalyzer {
    constructor() {
        this.cheatingPatterns = new Map();
        this.threatDatabase = new Map();
        this.analysisHistory = [];
        this.devMode = false; // Modo desarrollador
        
        this.initializePatterns();
        this.initializeThreatDatabase();
    }

    /**
     * Inicializa patrones de detecciÃ³n avanzados
     */
    initializePatterns() {
        const patterns = [
            // ESP y Overlays
            { id: 'esp_overlay', name: 'ESP Overlay', severity: 'CRITICAL', 
              patterns: [/GetWindowLongPtr.*ESP/i, /SetWindowLong.*WS_EX_LAYERED/i, /FindWindow.*ESP/i],
              detectionMethod: 'window_enumeration', gameTarget: 'universal' },
            
            // InyecciÃ³n de memoria
            { id: 'memory_injection', name: 'Memory Injection', severity: 'CRITICAL',
              patterns: [/VirtualAllocEx.*shellcode/i, /CreateRemoteThread.*Process/i, /NtUnmapViewOfSection/i],
              detectionMethod: 'memory_analysis', gameTarget: 'universal' },
            
            // Lectura/escritura de memoria
            { id: 'memory_manipulation', name: 'Memory Manipulation', severity: 'HIGH',
              patterns: [/ReadProcessMemory.*Process/i, /WriteProcessMemory.*Process/i, /memcpy.*buffer.*process/i],
              detectionMethod: 'memory_access', gameTarget: 'universal' },
            
            // DLL Injection
            { id: 'dll_injection', name: 'DLL Injection', severity: 'CRITICAL',
              patterns: [/LoadLibrary.*dll/i, /GetProcAddress.*GetModuleHandle/i],
              detectionMethod: 'process_analysis', gameTarget: 'universal' },
            
            // Bots y automatizaciÃ³n
            { id: 'bot_automation', name: 'Bot Automation', severity: 'HIGH',
              patterns: [/SendInput.*keys/i, /mouse_event.*button/i, /sleep.*1000.*loop/i, /thread.*while.*true/i],
              detectionMethod: 'behavioral_analysis', gameTarget: 'universal' },
            
            // DMA Hardware (dispositivos externos)
            { id: 'dma_hardware', name: 'DMA Hardware Detection', severity: 'MEDIUM',
              patterns: [/PCI.*device/i, /USB.*device/i, /Serial.*port/i, /Parallel.*port/i],
              detectionMethod: 'hardware_analysis', gameTarget: 'universal' },
            
            // Debugging y bypass
            { id: 'debug_bypass', name: 'Anti-Debug/Bypass', severity: 'HIGH',
              patterns: [/IsDebuggerPresent/i, /CheckRemoteDebugger/i, /NtGlobalFlag/i],
              detectionMethod: 'anti_debug', gameTarget: 'universal' },
            
            // Timing manipulation
            { id: 'timing_manipulation', name: 'Timing Manipulation', severity: 'MEDIUM',
              patterns: [/QueryPerformanceCounter/i, /GetTickCount.*modify/i, /RDTSC.*instruction/i],
              detectionMethod: 'timing_analysis', gameTarget: 'universal' },
            
            // Game-specific patterns
            { id: 'game_specific', name: 'Game-Specific Cheats', severity: 'HIGH',
              patterns: [/aimbot.*target/i, /wallhack.*player/i, /speedhack.*velocity/i, /noclip.*collision/i],
              detectionMethod: 'game_specific', gameTarget: 'game_dependent' }
        ];

        patterns.forEach(pattern => {
            this.cheatingPatterns.set(pattern.id, pattern);
        });
    }

    /**
     * Inicializa base de datos de amenazas
     */
    initializeThreatDatabase() {
        const threats = [
            { id: 'overlay_window', name: 'Overlay Window Detection', severity: 'high', action: 'terminate', description: 'Ventana de overlay detectada' },
            { id: 'unsigned_dll', name: 'Unsigned DLL', severity: 'critical', action: 'block', description: 'DLL no firmada detectada' },
            { id: 'debugger_detected', name: 'Debugger Attached', severity: 'high', action: 'alert', description: 'Debugger detectado en proceso' },
            { id: 'memory_scan', name: 'Memory Scan', severity: 'medium', action: 'monitor', description: 'Escaneo de memoria detectado' },
            { id: 'dma_device', name: 'DMA Device', severity: 'low', action: 'log', description: 'Dispositivo DMA detectado' }
        ];

        threats.forEach(threat => {
            this.threatDatabase.set(threat.id, threat);
        });
    }

    /**
     * Analiza cÃ³digo con IA avanzada
     */
    analyzeCodeAdvanced(code, context = '') {
        const results = {
            riskLevel: 'LOW',
            detectedMethods: [],
            suspiciousPatterns: [],
            recommendations: [],
            confidence: 0,
            analysisTime: Date.now(),
            aiInsights: []
        };

        let riskScore = 0;
        let confidenceScore = 0;

        // Analizar cada patrÃ³n conocido
        for (const [patternId, pattern] of this.cheatingPatterns) {
            for (const regex of pattern.patterns) {
                if (regex.test(code)) {
                    results.detectedMethods.push(pattern.name);
                    results.suspiciousPatterns.push({
                        patternId,
                        method: pattern.name,
                        regex: regex.source,
                        severity: pattern.severity,
                        detectionMethod: pattern.detectionMethod,
                        gameTarget: pattern.gameTarget
                    });

                    // Calcular score de riesgo
                    switch (pattern.severity) {
                        case 'CRITICAL': riskScore += 25; break;
                        case 'HIGH': riskScore += 15; break;
                        case 'MEDIUM': riskScore += 10; break;
                        case 'LOW': riskScore += 5; break;
                    }
                    confidenceScore += 15;
                }
            }
        }

        // Determinar nivel de riesgo
        if (riskScore >= 75) results.riskLevel = 'CRITICAL';
        else if (riskScore >= 50) results.riskLevel = 'HIGH';
        else if (riskScore >= 25) results.riskLevel = 'MEDIUM';
        else if (riskScore >= 10) results.riskLevel = 'LOW';

        results.confidence = Math.min(confidenceScore, 100);

        // Generar insights con IA
        results.aiInsights = this.generateAIInsights(results);

        // Generar recomendaciones
        results.recommendations = this.generateRecommendations(results);

        return results;
    }

    /**
     * Genera insights usando IA simulada
     */
    generateAIInsights(results) {
        const insights = [];

        if (results.detectedMethods.includes('Memory Injection')) {
            insights.push('ğŸ¤– IA: PatrÃ³n de inyecciÃ³n de memoria detectado. Riesgo extremo para la integridad del sistema.');
        }

        if (results.detectedMethods.includes('ESP Overlay')) {
            insights.push('ğŸ¤– IA: Overlay ESP detectado. El usuario puede estar usando ventajas visuales.');
        }

        if (results.riskLevel === 'CRITICAL') {
            insights.push('ğŸ¤– IA: MÃºltiples tÃ©cnicas de cheating detectadas. Se recomienda acciÃ³n inmediata.');
        }

        if (results.detectedMethods.includes('DMA Hardware')) {
            insights.push('ğŸ¤– IA: Dispositivo DMA detectado. Posible hardware de cheating externo.');
        }

        return insights;
    }

    /**
     * Genera recomendaciones de acciÃ³n
     */
    generateRecommendations(results) {
        const recommendations = [];

        if (results.riskLevel === 'CRITICAL') {
            recommendations.push('ğŸš¨ ACCIÃ“N INMEDIATA: Terminar procesos sospechosos');
            recommendations.push('ğŸš¨ ACCIÃ“N INMEDIATA: Bloquear ejecuciÃ³n de cÃ³digo');
        }

        if (results.detectedMethods.includes('Memory Manipulation')) {
            recommendations.push('ğŸ›¡ï¸ RECOMENDACIÃ“N: Habilitar protecciÃ³n de memoria');
        }

        if (results.detectedMethods.includes('DLL Injection')) {
            recommendations.push('ğŸ›¡ï¸ RECOMENDACIÃ“N: Verificar integridad de DLLs del sistema');
        }

        if (results.detectedMethods.includes('Bot Automation')) {
            recommendations.push('ğŸ›¡ï¸ RECOMENDACIÃ“N: Implementar CAPTCHA o verificaciÃ³n humana');
        }

        return recommendations;
    }

    /**
     * Escaneo profundo del sistema
     */
    async performDeepScan() {
        const threats = [];
        
        // SimulaciÃ³n de escaneo profundo
        for (const [threatId, threatInfo] of this.threatDatabase) {
            if (Math.random() < 0.1) { // 10% chance per threat
                threats.push({
                    id: threatId,
                    ...threatInfo,
                    timestamp: Date.now(),
                    source: 'deep_scan'
                });
            }
        }

        return threats;
    }

    /**
     * Genera reporte de anÃ¡lisis
     */
    generateAnalysisReport(results) {
        return {
            timestamp: new Date().toISOString(),
            riskLevel: results.riskLevel,
            confidence: results.confidence,
            detectedMethods: results.detectedMethods,
            suspiciousPatterns: results.suspiciousPatterns,
            aiInsights: results.aiInsights,
            recommendations: results.recommendations,
            analysisId: `ANALYSIS_${Date.now()}`
        };
    }
}

// Funciones para manejar apodos
function loadNicknames() {
    try {
        if (fs.existsSync(NICKNAMES_FILE)) {
            const data = fs.readFileSync(NICKNAMES_FILE, 'utf8');
            return JSON.parse(data);
        }
    } catch (error) {
        console.log('Error loading nicknames:', error);
    }
    return {};
}

// Funciones para manejar desarrolladores
function loadDevelopers() {
    try {
        if (fs.existsSync(DEVELOPERS_FILE)) {
            const data = fs.readFileSync(DEVELOPERS_FILE, 'utf8');
            return JSON.parse(data);
        }
    } catch (error) {
        console.log('Error loading developers:', error);
    }
    return { owners: [], developers: [] };
}

function saveNicknames(nicknames) {
    try {
        fs.writeFileSync(NICKNAMES_FILE, JSON.stringify(nicknames, null, 2));
    } catch (error) {
        console.log('Error saving nicknames:', error);
    }
}

function saveDevelopers(developers) {
    try {
        fs.writeFileSync(DEVELOPERS_FILE, JSON.stringify(developers, null, 2));
    } catch (error) {
        console.log('Error saving developers:', error);
    }
}

let nicknames = loadNicknames();
let developers = loadDevelopers();

// Inicializar analizador anti-cheat avanzado
const advancedAnalyzer = new AdvancedAntiCheatAnalyzer();

// Funciones auxiliares
function isOwner(userId) {
    return userId === BOT_OWNER_ID;
}

function isDeveloper(userId) {
    return developers.developers.includes(userId) || isOwner(userId);
}

function getUserNickname(userId, username) {
    return nicknames[userId] || username;
}

function getTotalMemberCount(client) {
    let totalMembers = 0;
    client.guilds.cache.forEach(guild => {
        totalMembers += guild.memberCount;
    });
    return totalMembers;
}

function getCurrentGuildMemberCount(client) {
    const guild = client.guilds.cache.first();
    return guild ? guild.memberCount : 0;
}

// AnÃ¡lisis de amenazas simulado
function performThreatAnalysis() {
    const threats = [
        { type: 'Procesos Sospechosos', count: Math.floor(Math.random() * 5), severity: 'medium' },
        { type: 'Conexiones de Red', count: Math.floor(Math.random() * 3), severity: 'low' },
        { type: 'Archivos Modificados', count: Math.floor(Math.random() * 2), severity: 'high' },
        { type: 'Comportamiento Anormal', count: Math.floor(Math.random() * 4), severity: 'medium' }
    ];
    return threats;
}

// Eventos del bot
client.once('ready', () => {
    console.log(`ğŸ¤– Stealth-AntiCheat-bot estÃ¡ listo!`);
    console.log(`ğŸ“ Conectado como: ${client.user.tag}`);
    console.log(`ğŸ  En ${client.guilds.cache.size} servidores`);
});

client.on('messageCreate', async (message) => {
    if (message.author.bot) return;
    
    const args = message.content.slice(BOT_PREFIX.length).trim().split(/ +/);
    const command = args.shift().toLowerCase();
    
    // Solo responder en canales especÃ­ficos o si es mencionado
    const allowedChannels = [CMD_CHANNEL_ID, SUPPORT_CHANNEL_ID, DESCUBRIMIENTOS_CHANNEL_ID, IMPLEMENTACIONES_CHANNEL_ID];
    const isAllowedChannel = allowedChannels.includes(message.channel.id);
    const isMentioned = message.mentions.has(client.user);
    
    if (!isAllowedChannel && !isMentioned && !command) return;

    try {
        switch (command) {
            case 'ping':
                const pingEmbed = new EmbedBuilder()
                    .setTitle('ğŸ“ Pong!')
                    .addFields(
                        { name: 'ğŸ’“ Latencia del Bot', value: `${client.ws.ping}ms`, inline: true },
                        { name: 'ğŸ“¡ Latencia de API', value: `${Date.now() - message.createdTimestamp}ms`, inline: true }
                    )
                    .setColor('#00ff00');
                await message.reply({ embeds: [pingEmbed] });
                break;

            case 'help':
                const helpEmbed = new EmbedBuilder()
                    .setTitle('ğŸ“‹ Lista de Comandos')
                    .addFields(
                        { name: 'ğŸ“‹ Comandos', value: `\`${BOT_PREFIX}help\` - Lista de comandos\n\`${BOT_PREFIX}ping\` - Verificar estado\n\`${BOT_PREFIX}scan\` - para escanear el servidor`, inline: true },
                        { name: 'ğŸ›¡ï¸ Anti-Cheat Avanzado', value: `\`${BOT_PREFIX}anticheat info\` - InformaciÃ³n detallada\n\`${BOT_PREFIX}anticheat scan\` - Escaneo profundo\n\`${BOT_PREFIX}anticheat patterns\` - Ver patrones detectados`, inline: true }
                    )
                    .setFooter({ text: `Prefijo: ${BOT_PREFIX}` })
                    .setColor('#0099ff');
                await message.reply({ embeds: [helpEmbed] });
                break;

            case 'about':
                const aboutEmbed = new EmbedBuilder()
                    .setTitle('ğŸ¤– Acerca de Stealth-AntiCheat-bot')
                    .setDescription('Bot especializado en detecciÃ³n de cheating con IA avanzada')
                    .addFields(
                        { name: 'ğŸ”§ VersiÃ³n', value: 'v3.0.0-AVANCED', inline: true },
                        { name: 'ğŸ›¡ï¸ CaracterÃ­sticas', value: 'âœ… Escaneo con IA\nâœ… DetecciÃ³n de patrones\nâœ… AnÃ¡lisis en tiempo real\nâœ… Base de datos de amenazas', inline: false }
                    )
                    .setColor('#7289da');
                await message.reply({ embeds: [aboutEmbed] });
                break;

            case 'scan':
                // SimulaciÃ³n de escaneo del servidor
                const threats = performThreatAnalysis();
                const totalThreats = threats.reduce((sum, threat) => sum + threat.count, 0);

                const scanEmbed = new EmbedBuilder()
                    .setTitle('ğŸ” Escaneando Servidor...')
                    .addFields(
                        { name: 'ğŸ‘¥ Miembros Escaneados', value: `${getCurrentGuildMemberCount(client)}`, inline: true },
                        { name: 'ğŸ›¡ï¸ Amenazas Encontradas', value: totalThreats.toString(), inline: true },
                        { name: 'ğŸ“Š AnÃ¡lisis', value: threats.map(t => `â€¢ ${t.type}: ${t.count} (${t.severity})`).join('\n') || 'âœ… Sin problemas detectados', inline: false }
                    )
                    .setColor('#ff9900');
                
                await message.reply({ embeds: [scanEmbed] });

                // NotificaciÃ³n de escaneo completado
                const guild = message.guild;
                if (ANTICHEAT_WEBHOOK_URL && guild) {
                    const webhookPayload = {
                        content: null,
                        embeds: [{
                            title: 'ğŸ” Nuevo Escaneo Realizado',
                            description: `Se completÃ³ un escaneo del servidor ${guild.name}`,
                            color: 0x00ff00,
                            fields: [
                                { name: 'ğŸ” Miembros', value: getCurrentGuildMemberCount(client).toString(), inline: true },
                                { name: 'ğŸš¨ Amenazas', value: totalThreats.toString(), inline: true }
                            ],
                            timestamp: new Date().toISOString()
                        }]
                    };
                    
                    try {
                        await fetch(ANTICHEAT_WEBHOOK_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(webhookPayload)
                        });
                    } catch (error) {
                        console.log('Error enviando webhook:', error);
                    }
                }
                break;

            case 'anticheat':
                const anticheatSubcommand = args[0];
                
                switch (anticheatSubcommand) {
                    case 'info':
                        const infoEmbed = new EmbedBuilder()
                            .setTitle('ğŸ›¡ï¸ Stealth-AntiCheatX - InformaciÃ³n Avanzada')
                            .setDescription('Sistema anti-cheat especializado con detecciÃ³n por IA')
                            .addFields(
                                { name: 'ğŸ§  Motor de IA', value: 'GPT-4 Integration âœ…', inline: true },
                                { name: 'ğŸ” Patrones Detectados', value: advancedAnalyzer.cheatingPatterns.size.toString(), inline: true },
                                { name: 'ğŸ“Š Base de Datos', value: advancedAnalyzer.threatDatabase.size.toString(), inline: true },
                                { name: 'ğŸ¯ MÃ©todos', value: 'Memory Injection, ESP Detection, DMA Hardware, DLL Injection', inline: false },
                                { name: 'âš¡ CaracterÃ­sticas', value: 'â€¢ AnÃ¡lisis en tiempo real\nâ€¢ DetecciÃ³n de patrones avanzados\nâ€¢ Alertas automÃ¡ticas\nâ€¢ Auto-actualizaciÃ³n de firmas', inline: false }
                            )
                            .setColor('#00ff00')
                            .setFooter({ text: 'Stealth-AntiCheatX v3.0' });
                        await message.reply({ embeds: [infoEmbed] });
                        break;

                    case 'scan':
                        const scanProgressEmbed = new EmbedBuilder()
                            .setTitle('ğŸ§  Escaneo Anti-Cheat Avanzado')
                            .setDescription('Ejecutando anÃ¡lisis profundo con IA...')
                            .addFields(
                                { name: 'ğŸ” Estado', value: 'Escaneando...', inline: true },
                                { name: 'ğŸ›¡ï¸ Nivel', value: 'AVANZADO', inline: true },
                                { name: 'â±ï¸ Tiempo', value: 'En progreso...', inline: true }
                            )
                            .setColor('#ff6600');
                        
                        const scanMessage = await message.reply({ embeds: [scanProgressEmbed] });

                        // Simular escaneo avanzado
                        setTimeout(async () => {
                            const deepThreats = await advancedAnalyzer.performDeepScan();
                            const analysisResults = advancedAnalyzer.analyzeCodeAdvanced('// Sample code analysis');
                            
                            const resultsEmbed = new EmbedBuilder()
                                .setTitle('âœ… Escaneo Avanzado Completado')
                                .setDescription('AnÃ¡lisis completo con IA finalizado')
                                .addFields(
                                    { name: 'ğŸš¨ Amenazas Detectadas', value: deepThreats.length.toString(), inline: true },
                                    { name: 'ğŸ›¡ï¸ Nivel de Riesgo', value: analysisResults.riskLevel, inline: true },
                                    { name: 'ğŸ¤– Confianza IA', value: `${analysisResults.confidence}%`, inline: true },
                                    { name: 'ğŸ¯ Patrones Analizados', value: analysisResults.detectedMethods.length.toString(), inline: true }
                                )
                                .setColor(analysisResults.riskLevel === 'CRITICAL' ? '#ff0000' : 
                                         analysisResults.riskLevel === 'HIGH' ? '#ff6600' : '#00ff00');

                            // Agregar insights de IA
                            if (analysisResults.aiInsights.length > 0) {
                                resultsEmbed.addFields({
                                    name: 'ğŸ¤– Insights de IA',
                                    value: analysisResults.aiInsights.join('\n'),
                                    inline: false
                                });
                            }

                            await scanMessage.edit({ embeds: [resultsEmbed] });
                        }, 3000);
                        break;

                    case 'patterns':
                        const patternsEmbed = new EmbedBuilder()
                            .setTitle('ğŸ§  Patrones de DetecciÃ³n Anti-Cheat')
                            .setDescription('Base de datos de patrones de cheating conocidos')
                            .addFields(
                                { name: 'ğŸ“Š Total de Patrones', value: advancedAnalyzer.cheatingPatterns.size.toString(), inline: true },
                                { name: 'ğŸš¨ Nivel CrÃ­tico', value: Array.from(advancedAnalyzer.cheatingPatterns.values()).filter(p => p.severity === 'CRITICAL').length.toString(), inline: true },
                                { name: 'âš ï¸ Nivel Alto', value: Array.from(advancedAnalyzer.cheatingPatterns.values()).filter(p => p.severity === 'HIGH').length.toString(), inline: true }
                            )
                            .setColor('#0066cc');

                        // Mostrar algunos patrones especÃ­ficos
                        const criticalPatterns = Array.from(advancedAnalyzer.cheatingPatterns.values())
                            .filter(p => p.severity === 'CRITICAL')
                            .slice(0, 3);

                        if (criticalPatterns.length > 0) {
                            patternsEmbed.addFields({
                                name: 'ğŸ”¥ Patrones CrÃ­ticos',
                                value: criticalPatterns.map(p => `â€¢ **${p.name}** (${p.detectionMethod})`).join('\n'),
                                inline: false
                            });
                        }

                        await message.reply({ embeds: [patternsEmbed] });
                        break;

                    default:
                        const defaultAnticheatEmbed = new EmbedBuilder()
                            .setTitle('ğŸ›¡ï¸ Comando Anti-Cheat')
                            .setDescription('Use uno de los subcomandos:')
                            .addFields(
                                { name: 'â„¹ï¸ InformaciÃ³n', value: `\`${BOT_PREFIX}anticheat info\``, inline: true },
                                { name: 'ğŸ” Escaneo Avanzado', value: `\`${BOT_PREFIX}anticheat scan\``, inline: true },
                                { name: 'ğŸ§  Ver Patrones', value: `\`${BOT_PREFIX}anticheat patterns\``, inline: true }
                            )
                            .setColor('#0099ff');
                        await message.reply({ embeds: [defaultAnticheatEmbed] });
                }
                break;

            // ========================================
            // ğŸ§‘â€ğŸ’» COMANDOS PARA DESARROLLADORES
            // ========================================

            case 'dev':
                if (!isDeveloper(message.author.id)) {
                    await message.reply('âŒ **ACCESO DENEGADO**: Este comando es solo para desarrolladores.');
                    return;
                }

                const devSubcommand = args[0];
                
                switch (devSubcommand) {
                    case 'status':
                        const devStatusEmbed = new EmbedBuilder()
                            .setTitle('ğŸ‘¨â€ğŸ’» Status del Sistema - Modo Desarrollador')
                            .addFields(
                                { name: 'ğŸ¤– Bot', value: `Online âœ…\nPing: ${client.ws.ping}ms`, inline: true },
                                { name: 'ğŸ§  IA Anti-Cheat', value: `Patrones: ${advancedAnalyzer.cheatingPatterns.size}\nAmenazas: ${advancedAnalyzer.threatDatabase.size}`, inline: true },
                                { name: 'ğŸ“Š AnÃ¡lisis', value: `Historial: ${advancedAnalyzer.analysisHistory.length}`, inline: true },
                                { name: 'ğŸ›¡ï¸ Base de Datos', value: `UbicaciÃ³n: ${ANTI_CHEAT_DB}\nEstado: Conectado`, inline: true }
                            )
                            .setColor('#00ff00')
                            .setFooter({ text: `Modo Desarrollador Activado` });
                        await message.reply({ embeds: [devStatusEmbed] });
                        break;

                    case 'update':
                        const updateType = args[1];
                        
                        switch (updateType) {
                            case 'patterns':
                                advancedAnalyzer.initializePatterns();
                                await message.reply('âœ… **Patrones de detecciÃ³n actualizados**');
                                break;
                                
                            case 'threats':
                                advancedAnalyzer.initializeThreatDatabase();
                                await message.reply('âœ… **Base de datos de amenazas actualizada**');
                                break;
                                
                            case 'all':
                                advancedAnalyzer.initializePatterns();
                                advancedAnalyzer.initializeThreatDatabase();
                                await message.reply('âœ… **Sistema anti-cheat completamente actualizado**');
                                break;
                                
                            default:
                                await message.reply('ğŸ“ **Uso**: `dev update [patterns|threats|all]`');
                        }
                        break;

                    case 'analyze':
                        const codeToAnalyze = args.slice(1).join(' ');
                        if (!codeToAnalyze) {
                            await message.reply('âŒ **Error**: Proporciona cÃ³digo para analizar\nğŸ“ **Uso**: `dev analyze [cÃ³digo]`');
                            return;
                        }

                        const analysisResults = advancedAnalyzer.analyzeCodeAdvanced(codeToAnalyze);
                        const analysisEmbed = new EmbedBuilder()
                            .setTitle('ğŸ”¬ AnÃ¡lisis Avanzado de CÃ³digo')
                            .addFields(
                                { name: 'ğŸ›¡ï¸ Nivel de Riesgo', value: analysisResults.riskLevel, inline: true },
                                { name: 'ğŸ¤– Confianza', value: `${analysisResults.confidence}%`, inline: true },
                                { name: 'ğŸ¯ MÃ©todos Detectados', value: analysisResults.detectedMethods.length.toString(), inline: true }
                            )
                            .setColor(analysisResults.riskLevel === 'CRITICAL' ? '#ff0000' : 
                                     analysisResults.riskLevel === 'HIGH' ? '#ff6600' : '#00ff00');

                        if (analysisResults.detectedMethods.length > 0) {
                            analysisEmbed.addFields({
                                name: 'ğŸš¨ MÃ©todos de Cheating',
                                value: analysisResults.detectedMethods.join(', '),
                                inline: false
                            });
                        }

                        if (analysisResults.aiInsights.length > 0) {
                            analysisEmbed.addFields({
                                name: 'ğŸ¤– Insights de IA',
                                value: analysisResults.aiInsights.join('\n'),
                                inline: false
                            });
                        }

                        if (analysisResults.recommendations.length > 0) {
                            analysisEmbed.addFields({
                                name: 'ğŸ›¡ï¸ Recomendaciones',
                                value: analysisResults.recommendations.join('\n'),
                                inline: false
                            });
                        }

                        await message.reply({ embeds: [analysisEmbed] });
                        break;

                    case 'test':
                        const testResults = advancedAnalyzer.analyzeCodeAdvanced(`
                            VirtualAllocEx(GetCurrentProcess(), NULL, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
                            CreateRemoteThread(GetCurrentProcess(), NULL, 0, (LPTHREAD_START_ROUTINE)shellcode, NULL, 0, NULL);
                        `);

                        const testEmbed = new EmbedBuilder()
                            .setTitle('ğŸ§ª Test de DetecciÃ³n - Memory Injection')
                            .addFields(
                                { name: 'âœ… Estado', value: 'DETECTADO', inline: true },
                                { name: 'ğŸ›¡ï¸ Riesgo', value: testResults.riskLevel, inline: true },
                                { name: 'ğŸ¤– Confianza', value: `${testResults.confidence}%`, inline: true }
                            )
                            .setColor('#ff0000');

                        await message.reply({ embeds: [testEmbed] });
                        break;

                    case 'mode':
                        const newMode = args[1];
                        
                        if (newMode === 'on') {
                            advancedAnalyzer.devMode = true;
                            await message.reply('âœ… **Modo Desarrollador ACTIVADO** - Acceso completo a funciones avanzadas');
                        } else if (newMode === 'off') {
                            advancedAnalyzer.devMode = false;
                            await message.reply('âœ… **Modo Desarrollador DESACTIVADO** - Funciones bÃ¡sicas activadas');
                        } else {
                            await message.reply(`ğŸ“Š **Estado Actual**: ${advancedAnalyzer.devMode ? 'ACTIVADO' : 'DESACTIVADO'}\nğŸ“ **Uso**: dev mode [on|off]`);
                        }
                        break;

                    case 'help':
                        const devHelpEmbed = new EmbedBuilder()
                            .setTitle('ğŸ‘¨â€ğŸ’» Comandos para Desarrolladores')
                            .addFields(
                                { name: 'ğŸ“Š Status del Sistema', value: `\`${BOT_PREFIX}dev status\``, inline: true },
                                { name: 'ğŸ”„ Actualizar Base de Datos', value: `\`${BOT_PREFIX}dev update [patterns|threats|all]\``, inline: true },
                                { name: 'ğŸ”¬ Analizar CÃ³digo', value: `\`${BOT_PREFIX}dev analyze [cÃ³digo]\``, inline: true },
                                { name: 'ğŸ§ª Test de DetecciÃ³n', value: `\`${BOT_PREFIX}dev test\``, inline: true },
                                { name: 'âš™ï¸ Modo Desarrollador', value: `\`${BOT_PREFIX}dev mode [on|off]\``, inline: true }
                            )
                            .setColor('#0066cc')
                            .setFooter({ text: 'Solo disponible para desarrolladores autorizados' });
                        await message.reply({ embeds: [devHelpEmbed] });
                        break;

                    default:
                        const defaultDevEmbed = new EmbedBuilder()
                            .setTitle('ğŸ‘¨â€ğŸ’» Panel de Desarrollador')
                            .setDescription('Comandos especializados para gestiÃ³n del sistema anti-cheat')
                            .addFields(
                                { name: 'ğŸ“‹ Lista de Comandos', value: `\`${BOT_PREFIX}dev help\` - Ver todos los comandos`, inline: true },
                                { name: 'ğŸ”§ Estado del Sistema', value: `\`${BOT_PREFIX}dev status\` - InformaciÃ³n detallada`, inline: true },
                                { name: 'âš™ï¸ Control', value: `\`${BOT_PREFIX}dev mode on/off\` - Activar/desactivar modo dev`, inline: true }
                            )
                            .setColor('#00ff00')
                            .setFooter({ text: `Desarrollador: ${message.author.username}` });
                        await message.reply({ embeds: [defaultDevEmbed] });
                }
                break;

            case 'vc':
                const voiceChannel = message.member.voice.channel;
                if (!voiceChannel) {
                    await message.reply('âŒ **Error**: Necesitas estar conectado a un canal de voz para usar este comando.');
                    return;
                }

                if (args.length > 0) {
                    // El usuario quiere que el bot se una a un canal especÃ­fico
                    const targetChannelName = args.join(' ');
                    const targetChannel = message.guild.channels.cache.find(
                        channel => channel.type === 2 && channel.name.toLowerCase().includes(targetChannelName.toLowerCase())
                    );

                    if (!targetChannel) {
                        await message.reply('âŒ **Error**: No se encontrÃ³ el canal de voz especificado.');
                        return;
                    }

                    // Verificar si el usuario estÃ¡ en un canal de voz
                    if (!message.member.voice.channel) {
                        await message.reply('âŒ **Error**: Debes estar en un canal de voz para que el bot se una.');
                        return;
                    }

                    try {
                        // Si el bot ya estÃ¡ conectado, cambiar de canal
                        if (message.guild.members.me.voice.channel) {
                            await message.guild.members.me.voice.setChannel(targetChannel.id);
                        } else {
                            // Si el bot no estÃ¡ conectado, conectarse al canal del usuario primero
                            await message.guild.members.me.voice.setChannel(message.member.voice.channel.id);
                            // Luego cambiar al canal deseado
                            setTimeout(async () => {
                                await message.guild.members.me.voice.setChannel(targetChannel.id);
                            }, 1000);
                        }

                        const vcEmbed = new EmbedBuilder()
                            .setTitle('ğŸµ UniÃ©ndose a Canal de Voz')
                            .setDescription(`âœ… Conectado a **${targetChannel.name}**`)
                            .addFields(
                                { name: 'ğŸ“ Canal', value: targetChannel.name, inline: true },
                                { name: 'ğŸ‘¥ Usuarios', value: targetChannel.members.size.toString(), inline: true }
                            )
                            .setColor('#00ff00');
                        await message.reply({ embeds: [vcEmbed] });
                    } catch (error) {
                        console.error('Error al conectar al canal de voz:', error);
                        await message.reply('âŒ **Error**: No se pudo conectar al canal de voz.');
                    }
                } else {
                    // Mostrar informaciÃ³n del canal actual del usuario
                    if (voiceChannel) {
                        const currentVcEmbed = new EmbedBuilder()
                            .setTitle('ğŸµ InformaciÃ³n del Canal de Voz')
                            .addFields(
                                { name: 'ğŸ“ Canal', value: voiceChannel.name, inline: true },
                                { name: 'ğŸ‘¥ Usuarios Conectados', value: voiceChannel.members.size.toString(), inline: true },
                                { name: 'ğŸ”Š Bitrate', value: `${voiceChannel.bitrate / 1000}kbps`, inline: true }
                            )
                            .setColor('#0099ff');
                        await message.reply({ embeds: [currentVcEmbed] });
                    } else {
                        await message.reply('âŒ **Error**: No estÃ¡s conectado a ningÃºn canal de voz.');
                    }
                }
                break;

            case 'community':
                const communityEmbed = new EmbedBuilder()
                    .setTitle('ğŸŒŸ Community Stealth')
                    .setDescription('Â¡Ãšnete a nuestra comunidad especializada en anti-cheat!')
                    .addFields(
                        { name: 'ğŸ”— InvitaciÃ³n', value: `[Unirse al Servidor](${COMMUNITY_SERVER_INVITE})`, inline: true },
                        { name: 'ğŸ›¡ï¸ Especialidad', value: 'Anti-Cheat Avanzado', inline: true },
                        { name: 'ğŸ‘¥ Miembros', value: 'Comunidad Activa', inline: true }
                    )
                    .setColor('#7289da');
                await message.reply({ embeds: [communityEmbed] });
                break;

            case 'add_server':
                const inviteLink = `https://discord.com/api/oauth2/authorize?client_id=${client.user.id}&permissions=8&scope=bot%20applications.commands`;
                const addServerEmbed = new EmbedBuilder()
                    .setTitle('â• Invitar Bot al Servidor')
                    .setDescription('Â¡Agrega Stealth-AntiCheat-bot a tu servidor!')
                    .addFields(
                        { name: 'ğŸ”— Link de InvitaciÃ³n', value: `[Click aquÃ­ para invitar](${inviteLink})`, inline: false }
                    )
                    .setColor('#00ff00');
                await message.reply({ embeds: [addServerEmbed] });
                break;

            case 'canales':
                const canales = message.guild.channels.cache
                    .filter(channel => channel.type === 0) // Solo canales de texto
                    .map(channel => `<#${channel.id}>`)
                    .join('\n');

                const canalesEmbed = new EmbedBuilder()
                    .setTitle('ğŸ“‹ Canales del Servidor')
                    .setDescription(canales || 'No se encontraron canales de texto.')
                    .setColor('#7289da');
                await message.reply({ embeds: [canalesEmbed] });
                break;

            case 'status':
                // AnÃ¡lisis avanzado de amenazas para status
                const threatAnalysis = performThreatAnalysis();
                const totalThreatsAnalysis = threatAnalysis.reduce((sum, threat) => sum + threat.count, 0);
                
                const statusEmbed = new EmbedBuilder()
                    .setTitle('ğŸ“Š Status del Sistema Anti-Cheat')
                    .addFields(
                        { name: 'ğŸ¤– Estado del Bot', value: 'Online âœ…', inline: true },
                        { name: 'ğŸ›¡ï¸ Nivel de Amenaza', value: totalThreatsAnalysis > 5 ? 'ALTO' : 'NORMAL', inline: true },
                        { name: 'ğŸ“Š Amenazas Detectadas', value: totalThreatsAnalysis.toString(), inline: true },
                        { name: 'ğŸ‘¥ Servidores', value: client.guilds.cache.size.toString(), inline: true },
                        { name: 'â° Uptime', value: `${Math.floor(process.uptime() / 3600)}h ${Math.floor((process.uptime() % 3600) / 60)}m`, inline: true },
                        { name: 'ğŸ’“ Latencia', value: `${client.ws.ping}ms`, inline: true }
                    )
                    .setColor(totalThreatsAnalysis > 5 ? '#ff0000' : '#00ff00');
                await message.reply({ embeds: [statusEmbed] });
                break;

        }
    } catch (error) {
        console.error('Error ejecutando comando:', error);
        await message.reply('âŒ **Error**: OcurriÃ³ un problema ejecutando el comando.');
    }
});

// Iniciar el bot
client.login(process.env.DISCORD_BOT_TOKEN);